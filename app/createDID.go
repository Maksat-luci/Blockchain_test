package app

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	didcrypto "spider/x/did/client/cli/crypto"
	"spider/x/did/secp256k1util"
	"spider/x/did/types"

	"github.com/cosmos/cosmos-sdk/client/input"
	"github.com/cosmos/go-bip39"
	"github.com/tendermint/tendermint/crypto/secp256k1"
)

const (
	flagInteractive = "interactive"
	baseDir         = "did_keystore"
)

// readBIP39ParamsFrom reads a mnemonic and a bip39 passphrase from the reader in the interactive mode.
// It returns empty strings in the non-interactive mode, so that they can be auto-generated by crypto.GenSecp256k1PrivKey.
func readBIP39ParamsFrom(interactive bool, reader *bufio.Reader) (string, string, error) {
	if !interactive {
		return "", "", nil
	}

	// mnemonic can be an empty string
	mnemonic, err := input.GetString("Enter your BIP39 mnemonic, or hit enter to generate one:", reader)
	if err != nil {
		return "", "", err
	}
	if mnemonic != "" && !bip39.IsMnemonicValid(mnemonic) {
		return "", "", fmt.Errorf("invalid mnemonic")
	}

	// passphrase can be an empty string
	passphrase, err := input.GetString("Enter your BIP39 passphrase, or hit enter:", reader)
	if err != nil {
		return "", "", err
	}
	if passphrase != "" {
		repeat, err := input.GetString("Repeat the passphrase:", reader)
		if err != nil {
			return "", "", err
		}
		if passphrase != repeat {
			return "", "", fmt.Errorf("passphrases don't match")
		}
	}

	return mnemonic, passphrase, nil

}

// newMsgCreateDID creates a MsgCreateDID by generating a DID and a DID document from the networkID and privKey.
// It generates the minimal DID document which contains only one public key information,
// so that it can be extended by MsgUpdateDID later.
func newMsgCreateDID(fromAddress string, privKey secp256k1.PrivKey) (*types.MsgCreateDID, error) {
	pubKey := secp256k1util.PubKeyBytes(secp256k1util.DerivePubKey(privKey))
	did := types.NewDID(pubKey)
	verificationMethodID := types.NewVerificationMethodID(did, "key1")
	verificationMethod := types.NewVerificationMethod(verificationMethodID, types.ES256K_2019, did, pubKey)
	verificationMethods := []*types.VerificationMethod{
		&verificationMethod,
	}
	relationship := types.NewVerificationRelationship(verificationMethods[0].Id)
	authentications := []types.VerificationRelationship{
		relationship,
	}
	doc := types.NewDIDDocument(did, types.WithVerificationMethods(verificationMethods), types.WithAuthentications(authentications))

	sig, err := types.Sign(doc, types.InitialSequence, privKey)
	if err != nil {
		return &types.MsgCreateDID{}, err
	}

	msg := types.NewMsgCreateDID(did, doc, verificationMethodID, sig, fromAddress)
	if err := msg.ValidateBasic(); err != nil {
		return &types.MsgCreateDID{}, err
	}
	return msg, nil
}

func savePrivKeyToKeyStore(verificationMethodID string, privKey secp256k1.PrivKey, reader *bufio.Reader) error {
	passwd, err := getCheckPassword(reader)
	if err != nil {
		return err
	}
	ks, err := didcrypto.NewKeyStore(keystoreBaseDir())
	if err != nil {
		return err
	}
	_, err = ks.Save(verificationMethodID, privKey[:], passwd)
	return err
}

func keystoreBaseDir() string {
	path, _ := os.Getwd()
	return filepath.Join(path, baseDir)
}

func getCheckPassword(reader *bufio.Reader) (string, error) {
	// pass, err := input.GetPassword(
	// 	"Enter a password to encrypt your key for DID to disk:",
	// 	reader,
	// )
	// if err != nil {
	// 	return "", err
	// }

	// pass2, err := input.GetPassword(
	// 	"Repeat the password:",
	// 	reader,
	// )
	// if err != nil {
	// 	return "", err
	// }
	// if pass != pass2 {
	// 	return "", errors.New("passphrases don't match")
	// }
	pas := "MaksaT123"
	return pas, nil
}
